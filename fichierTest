import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

const ListIdOfRecipesByUstensils = {};
let listValideRecipeByUst = [];

let ustensil;


/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (ListIdOfRecipesByUstensils[ustensil] === undefined) ListIdOfRecipesByUstensils[ustensil] = [];
            ListIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return ListIdOfRecipesByUstensils;
}


/**
 * Récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    let data;
    console.log(listValideRecipeByUst.length);
    if (listValideRecipeByUst.length > 0) return listValideRecipeByUst;

    return data = recipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture
 *
 *
 * @return  {Object}         liste des ustensils
 */
export function initUstensilsList() {

    //Si activeTag ne contient aucun ustensil, on initialise le bouton avec 
    //un Set qui prend l'ensemble des ustensils de l'ensemble des recettes
    if (activeTag.ustensils.length === 0) {
        ustensil = new Set();
        recipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    }
    //Si activeTag.length est superieur à 0 prendre la list des ustensils dans listValideRecipesByUst
    if (activeTag.ustensils.length > 0) {
        ustensil = new Set();
        listValideRecipeByUst.forEach(rec => { //BUG probleme au réaffichage 
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    }

    return ustensil;
}

/**
 * Ressort les recette valides
 *
 * @param   {String}  value  valeur cliqué sur le bouton
 *
 */
export function updateAvailableRecipes(value) {

    //Ajout des tags dans activeTag
    const index = activeTag.ustensils.indexOf(value);
    if (index === -1) {
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.slice(index, 1)
    }

    // console.log(listValideRecipeByUst.length);

    //Si il n'y a pas de recette dans listValideRecipeByUst, on envoie
    //toutes les recette de recipes qui contiennent un ustensil = à value
    if (listValideRecipeByUst.length === 0) {
        for (let id of Object.keys(ListIdOfRecipesByUstensils)) {
            if (id == value) {
                for (let num of Object.values(ListIdOfRecipesByUstensils[id])) {
                    listValideRecipeByUst.push(recipes[num])
                }
            }
        }
    } else {
        //Si listValideRecipeByUst contient deja des recettes, on refiltre listValideRecipeByUst
        //en récuperant les recettes qui contiennent la nouvelle value
        for (let id of Object.keys(ListIdOfRecipesByUstensils)) {
            if (id == value) {
                for (let num of Object.values(ListIdOfRecipesByUstensils[id])) {
                    listValideRecipeByUst.push(listValideRecipeByUst[num])
                }
            }
        }
    }
}





P2


JAVASCRIPT

import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

const listIdOfRecipesByUstensils = {};
let listValideRecipeByUst = [];

let ustensil;


/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    initIdUstensils()
    let data;
    listValideRecipeByUst.length > 0 ? data = listValideRecipeByUst : data = recipes;
    return data;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 *
 * @return  {Object}         liste des ustensils
 */
export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    if(activeTag.ustensils.length === 0){
        ustensil = new Set();
        recipes.forEach(rec => {
            for(let ust of rec.ustensils){
                ustensil.add(ust);
            }
        })
    } else {
        //modification si activeTag > 0
        ustensil = new Set ();
        listValideRecipeByUst.forEach(rec => {
            for(let ust of rec.ustensils){
                ustensil.add(ust)
            }
        })
    }  

    return ustensil;
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value) {
    let index = activeTag.ustensils.indexOf(value)
    if(index === -1){
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.splice(index, 1);
    }
}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @param   {String}  value  valeur cliqué sur le bouton
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length > 0){
        for(let ust of activeTag.ustensils){
            for(let key of Object.keys(listIdOfRecipesByUstensils)){
                if(ust === key){
                    for(let id of Object.values(listIdOfRecipesByUstensils[key])){
                        listValideRecipeByUst.push(recipes[id]);
                    }
                }
            }
        }
        return listValideRecipeByUst;
    }
}


/**
 * Retrait des tag au click sur la fleche 
 *
 * @param   {string}  value  valeur du bouton 
 *
 * @return  {void}  retrait du tag = a la valuer 
 */
export function removeTagOnClick (value){
    let indexRemove = activeTag.ustensils.indexOf(value);
    if(indexRemove != -1){
        activeTag.ustensils.splice(indexRemove, 1);
    }
}






JAVASCRIPT index


// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag, removeTagOnClick} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag, removeTag.bind(this));
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await updateUstensilsList();
    await makeActiveTag(value);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

async function removeTag (value){
    await removeTagOnClick(value);
    await updateUstensilsList();
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

























//NewDataManager

import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
const listIdOfRecipesByUstensils = {};


/**
 * Liste des id des recettes valides
 *
 * @var {Array}
 */
let listValideRecipeByUst = [];

/**
 * la liste des ustensils dipsonibles à l'ajout
 *
 * @type {Set}
 */
let ustensil;


initIdUstensils();

/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    if (listValideRecipeByUst.length === 0 ) return recipes; //TODO completer condition avec les autres cas
    let newRecipesId = [];

    //on ajoute les recette par ustensils
    if (listValideRecipeByUst.length > 0) newRecipesId = listValideRecipeByUst;

    const newReceipes = [];
    newRecipesId.forEach(id=>{
        newReceipes.push(recipes[id])
    })
    return newReceipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 * @return  {Set}         liste des ustensils
 */

export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    ustensil = new Set();
    
    for (const nomUstensil of Object.keys(listIdOfRecipesByUstensils)){
        if (activeTag.ustensils.indexOf(nomUstensil) === -1) ustensil.add(nomUstensil.toLowerCase())
    }
    return ustensil;
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value) {
    let index = activeTag.ustensils.indexOf(value)
    if(index === -1){
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.splice(index, 1);
    }
}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @return {void}
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length === 0) return;
    if(activeTag.ustensils.length === 1) {
    listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
    return;

    }

    for(const ust of activeTag.ustensils){
        updateMatchingList(listValideRecipeByUst, listIdOfRecipesByUstensils[ust])//BUG
        
    }
}


function updateMatchingList(refList, filterList){
    refList= refList.filter(value => {
        for (const num of filterList) {
            if(num === value){
                return num
            }
        }
        // if(filterList.includes(value)){
        //     return value;
        // }
    });
}


/**
 * Retrait des tag au click sur la fleche 
 *
 * @param   {string}  value  valeur du bouton 
 *
 * @return  {void}  retrait du tag = a la valuer 
 */
export function removeTagOnClick (value){ 
    let indexRemove = activeTag.ustensils.indexOf(value);
    if(indexRemove != -1){
        activeTag.ustensils.splice(indexRemove, 1);
    }
}
















//index


// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag, removeTagOnClick} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag, removeTag.bind(this));
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await initIdUstensils();
    await updateUstensilsList();
    await makeActiveTag(value);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

async function removeTag (value){
    await removeTagOnClick(value);
   
}














4eme et dernier test 

Page Index.js

// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag);
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await initIdUstensils();
    await updateUstensilsList();
    await makeActiveTag(value, type);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}





dataManager

// import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
const listIdOfRecipesByUstensils = {};

let newReceipes = [];


/**
 * Liste des id par ustensil des recettes valides
 *
 * @var {Array}
 */
let listValideRecipeByUst = [];

/**
 * la liste des ustensils dipsonibles à l'ajout
 *
 * @type {Set}
 */
let ustensil;



/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
 const listIdOfRecipesByAppliance = {};
 
 /**
  * Liste des id par appliance des recettes valides
  *
  * @var {Array}
  */
  let listValideRecipeByApp = [];


/**
 * La liste des appareil disponible à l'ajout
 *
 * @var {Set}
 */
let appliance;


initIdUstensils();
initIdAppliance();

/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            if (listIdOfRecipesByUstensils[ustensil].indexOf(i) === -1)listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Retourne une clé valeur pour l'ensemble des id des appareils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
 export function initIdAppliance() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        if (listIdOfRecipesByUstensils[[recipes[i].appliance]] === undefined) listIdOfRecipesByUstensils[[recipes[i].appliance]] = [];
        if (listIdOfRecipesByUstensils[[recipes[i].appliance]].indexOf(i) === -1)listIdOfRecipesByUstensils[[recipes[i].appliance]].push(i)
    };
    
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    console.log(activeTag);
    if (listValideRecipeByUst.length === 0 && listValideRecipeByApp.length === 0) return recipes; //TODO completer condition avec les autres cas
    let newRecipesId = [];
    newReceipes = [];

    //on ajoute les recette par ustensils
    if (listValideRecipeByUst.length > 0) newRecipesId = listValideRecipeByUst;

    newRecipesId.forEach(id=>{
        newReceipes.push(recipes[id]);
    })
    return newReceipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 * @return  {Array}         liste des ustensils
 */

export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    ustensil = new Set();
    if(activeTag.ustensils.length === 0){
        recipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    } else {
        ustensil = new Set();
        newReceipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust)
            });
        })
    }
    
    return [...ustensil];
}


/**
 * [export description]
 * Ajout des appareils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 * 
 * @return  {array}  [return description]
 */
export function updateApplianceList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    appliance = new Set();
    if(activeTag.appliance.length === 0){
        recipes.forEach(rec => {
            appliance.add(rec.appliance)
        })
    } else {
        appliance = new Set();
        newReceipes.forEach(rec => {
                appliance.add(rec.appliance)
        })
    }
    return [...appliance];
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value, type) {
    let indexUst = activeTag.ustensils.indexOf(value)
    let indexApp = activeTag.appliance.indexOf(value)
    console.log(type);
    if(type === 'Ustensils'){
        if(indexUst === -1){
            activeTag.ustensils.push(value);
        } else {
            activeTag.ustensils.splice(indexUst, 1);
        };
    }
    
    if(type === 'Appareil'){
        if(indexApp === -1){
            activeTag.appliance.push(value)
        } else {
            activeTag.appliance.splice(indexApp, 1);
        };
    }
    

}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @return {Array}
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length === 0 && activeTag.appliance.length === 0) return;
    if(activeTag.ustensils.length === 1 && activeTag.appliance.length === 0) {
    listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
    return;
    }
    if(activeTag.ustensils.length === 0 && activeTag.appliance.length === 1) {
        listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
        return;
        }
    

    for(const ust of activeTag.ustensils){
        listValideRecipeByUst  = updateMatchingList(listValideRecipeByUst, listIdOfRecipesByUstensils[ust])//BUG 
    }

    for (const App of activeTag.appliance){
 
    }


}


function updateMatchingList(refList, filterList){
    const newList = [];
    for (const id of refList){
        if ( filterList.indexOf(id) !==-1) newList.push(id)
    }
    return newList;
}


















































