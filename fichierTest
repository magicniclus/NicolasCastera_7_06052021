import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

const ListIdOfRecipesByUstensils = {};
let listValideRecipeByUst = [];

let ustensil;


/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (ListIdOfRecipesByUstensils[ustensil] === undefined) ListIdOfRecipesByUstensils[ustensil] = [];
            ListIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return ListIdOfRecipesByUstensils;
}


/**
 * Récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    let data;
    console.log(listValideRecipeByUst.length);
    if (listValideRecipeByUst.length > 0) return listValideRecipeByUst;

    return data = recipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture
 *
 *
 * @return  {Object}         liste des ustensils
 */
export function initUstensilsList() {

    //Si activeTag ne contient aucun ustensil, on initialise le bouton avec 
    //un Set qui prend l'ensemble des ustensils de l'ensemble des recettes
    if (activeTag.ustensils.length === 0) {
        ustensil = new Set();
        recipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    }
    //Si activeTag.length est superieur à 0 prendre la list des ustensils dans listValideRecipesByUst
    if (activeTag.ustensils.length > 0) {
        ustensil = new Set();
        listValideRecipeByUst.forEach(rec => { //BUG probleme au réaffichage 
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    }

    return ustensil;
}

/**
 * Ressort les recette valides
 *
 * @param   {String}  value  valeur cliqué sur le bouton
 *
 */
export function updateAvailableRecipes(value) {

    //Ajout des tags dans activeTag
    const index = activeTag.ustensils.indexOf(value);
    if (index === -1) {
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.slice(index, 1)
    }

    // console.log(listValideRecipeByUst.length);

    //Si il n'y a pas de recette dans listValideRecipeByUst, on envoie
    //toutes les recette de recipes qui contiennent un ustensil = à value
    if (listValideRecipeByUst.length === 0) {
        for (let id of Object.keys(ListIdOfRecipesByUstensils)) {
            if (id == value) {
                for (let num of Object.values(ListIdOfRecipesByUstensils[id])) {
                    listValideRecipeByUst.push(recipes[num])
                }
            }
        }
    } else {
        //Si listValideRecipeByUst contient deja des recettes, on refiltre listValideRecipeByUst
        //en récuperant les recettes qui contiennent la nouvelle value
        for (let id of Object.keys(ListIdOfRecipesByUstensils)) {
            if (id == value) {
                for (let num of Object.values(ListIdOfRecipesByUstensils[id])) {
                    listValideRecipeByUst.push(listValideRecipeByUst[num])
                }
            }
        }
    }
}





P2


JAVASCRIPT

import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

const listIdOfRecipesByUstensils = {};
let listValideRecipeByUst = [];

let ustensil;


/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    initIdUstensils()
    let data;
    listValideRecipeByUst.length > 0 ? data = listValideRecipeByUst : data = recipes;
    return data;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 *
 * @return  {Object}         liste des ustensils
 */
export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    if(activeTag.ustensils.length === 0){
        ustensil = new Set();
        recipes.forEach(rec => {
            for(let ust of rec.ustensils){
                ustensil.add(ust);
            }
        })
    } else {
        //modification si activeTag > 0
        ustensil = new Set ();
        listValideRecipeByUst.forEach(rec => {
            for(let ust of rec.ustensils){
                ustensil.add(ust)
            }
        })
    }  

    return ustensil;
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value) {
    let index = activeTag.ustensils.indexOf(value)
    if(index === -1){
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.splice(index, 1);
    }
}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @param   {String}  value  valeur cliqué sur le bouton
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length > 0){
        for(let ust of activeTag.ustensils){
            for(let key of Object.keys(listIdOfRecipesByUstensils)){
                if(ust === key){
                    for(let id of Object.values(listIdOfRecipesByUstensils[key])){
                        listValideRecipeByUst.push(recipes[id]);
                    }
                }
            }
        }
        return listValideRecipeByUst;
    }
}


/**
 * Retrait des tag au click sur la fleche 
 *
 * @param   {string}  value  valeur du bouton 
 *
 * @return  {void}  retrait du tag = a la valuer 
 */
export function removeTagOnClick (value){
    let indexRemove = activeTag.ustensils.indexOf(value);
    if(indexRemove != -1){
        activeTag.ustensils.splice(indexRemove, 1);
    }
}






JAVASCRIPT index


// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag, removeTagOnClick} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag, removeTag.bind(this));
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await updateUstensilsList();
    await makeActiveTag(value);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

async function removeTag (value){
    await removeTagOnClick(value);
    await updateUstensilsList();
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

























//NewDataManager

import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
const listIdOfRecipesByUstensils = {};


/**
 * Liste des id des recettes valides
 *
 * @var {Array}
 */
let listValideRecipeByUst = [];

/**
 * la liste des ustensils dipsonibles à l'ajout
 *
 * @type {Set}
 */
let ustensil;


initIdUstensils();

/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    if (listValideRecipeByUst.length === 0 ) return recipes; //TODO completer condition avec les autres cas
    let newRecipesId = [];

    //on ajoute les recette par ustensils
    if (listValideRecipeByUst.length > 0) newRecipesId = listValideRecipeByUst;

    const newReceipes = [];
    newRecipesId.forEach(id=>{
        newReceipes.push(recipes[id])
    })
    return newReceipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 * @return  {Set}         liste des ustensils
 */

export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    ustensil = new Set();
    
    for (const nomUstensil of Object.keys(listIdOfRecipesByUstensils)){
        if (activeTag.ustensils.indexOf(nomUstensil) === -1) ustensil.add(nomUstensil.toLowerCase())
    }
    return ustensil;
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value) {
    let index = activeTag.ustensils.indexOf(value)
    if(index === -1){
        activeTag.ustensils.push(value);
    } else {
        activeTag.ustensils.splice(index, 1);
    }
}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @return {void}
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length === 0) return;
    if(activeTag.ustensils.length === 1) {
    listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
    return;

    }

    for(const ust of activeTag.ustensils){
        updateMatchingList(listValideRecipeByUst, listIdOfRecipesByUstensils[ust])//BUG
        
    }
}


function updateMatchingList(refList, filterList){
    refList= refList.filter(value => {
        for (const num of filterList) {
            if(num === value){
                return num
            }
        }
        // if(filterList.includes(value)){
        //     return value;
        // }
    });
}


/**
 * Retrait des tag au click sur la fleche 
 *
 * @param   {string}  value  valeur du bouton 
 *
 * @return  {void}  retrait du tag = a la valuer 
 */
export function removeTagOnClick (value){ 
    let indexRemove = activeTag.ustensils.indexOf(value);
    if(indexRemove != -1){
        activeTag.ustensils.splice(indexRemove, 1);
    }
}
















//index


// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag, removeTagOnClick} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag, removeTag.bind(this));
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await initIdUstensils();
    await updateUstensilsList();
    await makeActiveTag(value);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}

async function removeTag (value){
    await removeTagOnClick(value);
   
}














4eme et dernier test 

Page Index.js

// Gestionnaire d'affichage
import { getRecipes, updateUstensilsList, activeTag, updateAvailableRecipes, initIdUstensils, makeActiveTag} from "../Data/dataManager.js"
import { Vignette } from "../Components/vignette.js";
import { FiltreButton } from "../Components/filtreButton.js";
import { AddTag } from "../Components/addTag.js";


let vignetteContainer;
let filterContainer;
let addTagBar;



/**
 * Gestion de l'affichage 
 *
 * @param   {HTMLElement}  domTarget  [domTarget description]
 *
 * @return  {void}             [return description]
 */
export async function init(domTarget) {
    addTagBar = document.createElement('aside');
    addTagBar.setAttribute('class', 'tagBar');
    await domTarget.appendChild(addTagBar);
    updateTagBar();
    filterContainer = document.createElement('div');
    filterContainer.setAttribute('class', 'filterContainer');
    await domTarget.appendChild(filterContainer);
    addBtnFilter();
    vignetteContainer = document.createElement('aside');
    vignetteContainer.setAttribute('class', 'vignette__container')
    await domTarget.appendChild(vignetteContainer);
    await updateMain();
}



/**
 * Gestion de l'affiche de la bar d'affichage des tag
 *
 * @return  {void}  [return description]
 */
function updateTagBar() {
    addTagBar.innerHTML = '';
    new AddTag(addTagBar, activeTag);
}



/**
 * Gestiond de l'affichage des boutons 
 *
 * @return  {void}  [return description]
 */
function addBtnFilter() {
    filterContainer.innerHTML = '';
    // new FiltreButton(filterContainer, updateBtnFilter.bind(this), 'Ingredients', 'Rechercher un ingrédient')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Appareil', 'Rechercher un appareil')

    new FiltreButton(filterContainer, updateTagList.bind(this), 'Ustensils', 'Rechercher un ustensil')
}



/**
 * Gestion de l'affichage des vignettes 
 *
 * @return  {void}  [return description]
 */
function updateMain() {
    vignetteContainer.innerHTML = '';
    getRecipes().forEach(recipes => {
        new Vignette(vignetteContainer, recipes)
    })
}



/**
 * Gestion de l'envoi des données aux bouton au click sur ces derniers
 * + mise à jour de l'affichage 
 *
 * @param   {string}  type   [type description]
 * @param   {string}  value  [value description]
 *
 */
async function updateTagList(type, value) {
    await initIdUstensils();
    await updateUstensilsList();
    await makeActiveTag(value, type);
    await updateAvailableRecipes()
    await updateMain();
    await updateTagBar();
}





dataManager

// import { init } from "../Pages/index.js";
import { recipes } from "./data.js";

/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
const listIdOfRecipesByUstensils = {};

let newReceipes = [];


/**
 * Liste des id par ustensil des recettes valides
 *
 * @var {Array}
 */
let listValideRecipeByUst = [];

/**
 * la liste des ustensils dipsonibles à l'ajout
 *
 * @type {Set}
 */
let ustensil;



/**
 * Liste des id des recettes par leurs ustensils 
 *
 * @var {Object}
 */
 const listIdOfRecipesByAppliance = {};
 
 /**
  * Liste des id par appliance des recettes valides
  *
  * @var {Array}
  */
  let listValideRecipeByApp = [];


/**
 * La liste des appareil disponible à l'ajout
 *
 * @var {Set}
 */
let appliance;


initIdUstensils();
initIdAppliance();

/**
 * Retourne une clé valeur pour l'ensemble des id des ustensils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
export function initIdUstensils() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        recipes[i].ustensils.forEach(ustensil => {
            if (listIdOfRecipesByUstensils[ustensil] === undefined) listIdOfRecipesByUstensils[ustensil] = [];
            if (listIdOfRecipesByUstensils[ustensil].indexOf(i) === -1)listIdOfRecipesByUstensils[ustensil].push(i)
        });
    }
    return listIdOfRecipesByUstensils;
}


/**
 * Retourne une clé valeur pour l'ensemble des id des appareils ok
 *
 * @return  {Object}  Renvoi un objet 
 */
 export function initIdAppliance() {
    for (let i = 0, size = recipes.length; i < size; i++) {
        if (listIdOfRecipesByUstensils[[recipes[i].appliance]] === undefined) listIdOfRecipesByUstensils[[recipes[i].appliance]] = [];
        if (listIdOfRecipesByUstensils[[recipes[i].appliance]].indexOf(i) === -1)listIdOfRecipesByUstensils[[recipes[i].appliance]].push(i)
    };
    
    return listIdOfRecipesByUstensils;
}


/**
 * Object de récuperation des tags actifs ok
 *
 * @var {Object} 
 */
export let activeTag = {
    appliance: [],
    ustensils: [],  //[couteau]
    ingredients: [],
    text: []
}


/**
 * Affichage des recttes
 *
 * @return  {Object}  L'ensemble des recettes
 */
export function getRecipes() {
    console.log(activeTag);
    if (listValideRecipeByUst.length === 0 && listValideRecipeByApp.length === 0) return recipes; //TODO completer condition avec les autres cas
    let newRecipesId = [];
    newReceipes = [];

    //on ajoute les recette par ustensils
    if (listValideRecipeByUst.length > 0) newRecipesId = listValideRecipeByUst;

    newRecipesId.forEach(id=>{
        newReceipes.push(recipes[id]);
    })
    return newReceipes;
}


/**
 * Ajout des ustensils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 *
 * @return  {Array}         liste des ustensils
 */

export function updateUstensilsList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    ustensil = new Set();
    if(activeTag.ustensils.length === 0){
        recipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust.toLowerCase())
            })
        })
    } else {
        ustensil = new Set();
        newReceipes.forEach(rec => {
            rec.ustensils.forEach(ust => {
                ustensil.add(ust)
            });
        })
    }
    
    return [...ustensil];
}


/**
 * [export description]
 * Ajout des appareils dans le bouton à l'ouverture,
 * et modification si activeTag > 0
 * 
 * @return  {array}  [return description]
 */
export function updateApplianceList() {
    //Ajout des ustensil dans le bouton à l'ouverture de la page
    appliance = new Set();
    if(activeTag.appliance.length === 0){
        recipes.forEach(rec => {
            appliance.add(rec.appliance)
        })
    } else {
        appliance = new Set();
        newReceipes.forEach(rec => {
                appliance.add(rec.appliance)
        })
    }
    return [...appliance];
}


/**
 * Ajout des tags actifs a activeTag
 *
 * @param   {string}  value  valeur de l'ustensil cliqué 
 *
 * @return  {void} 
 */
export function makeActiveTag (value, type) {
    let indexUst = activeTag.ustensils.indexOf(value)
    let indexApp = activeTag.appliance.indexOf(value)
    console.log(type);
    if(type === 'Ustensils'){
        if(indexUst === -1){
            activeTag.ustensils.push(value);
        } else {
            activeTag.ustensils.splice(indexUst, 1);
        };
    }
    
    if(type === 'Appareil'){
        if(indexApp === -1){
            activeTag.appliance.push(value)
        } else {
            activeTag.appliance.splice(indexApp, 1);
        };
    }
    

}


/**
 * Ressort les recette valides en fonction de l'id
 *
 * @return {Array}
 *
 */
export function updateAvailableRecipes() {
    if(activeTag.ustensils.length === 0 && activeTag.appliance.length === 0) return;
    if(activeTag.ustensils.length === 1 && activeTag.appliance.length === 0) {
    listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
    return;
    }
    if(activeTag.ustensils.length === 0 && activeTag.appliance.length === 1) {
        listValideRecipeByUst = listIdOfRecipesByUstensils[activeTag.ustensils[0]];
        return;
        }
    

    for(const ust of activeTag.ustensils){
        listValideRecipeByUst  = updateMatchingList(listValideRecipeByUst, listIdOfRecipesByUstensils[ust])//BUG 
    }

    for (const App of activeTag.appliance){
 
    }


}


function updateMatchingList(refList, filterList){
    const newList = [];
    for (const id of refList){
        if ( filterList.indexOf(id) !==-1) newList.push(id)
    }
    return newList;
}















































FilterButton 

import { updateUstensilsList, updateApplianceList, updateIngredientList } from "../Data/dataManagers.js";

export class FiltreButton {

    constructor(domTarget, callback, title, phrasing, callBackTaget) {
        this.tableHash = [];
        this.title = title;
        this.change = false;
        this.DOM = document.createElement('div');
        this.DOM.classList.add('filtreButton');
        this.DOM.classList.add(title);
        this.phrasing = phrasing;
        this.callback = callback;
        this.callBackTarget = callBackTaget;
        domTarget.appendChild(this.DOM)
        this.clickValue = false;
        this.render();
    }

    render() {
        this.DOM.innerHTML = "";
        this.filterTop = document.createElement('div');
        this.filterTop.setAttribute('class', 'filtreBoutton__filterTop');
        this.DOM.appendChild(this.filterTop);
        this.addInput(this.filterTop);
        this.secondRender();
    }

    secondRender(){
        this.addArrow(this.filterTop);
    }

    /**
     * [addInput description]
     *
     * @param   {HTMLElement}  parent  [parent description]
     *
     */
    addInput(parent) {
        const input = document.createElement('input');
        input.setAttribute('type', "text");
        input.setAttribute("id", this.title);
        input.setAttribute("name", this.title);
        input.setAttribute('placeholder', this.clickValue ? this.phrasing : this.title);
        parent.appendChild(input);

        /**
         * Affichage des tag au click sur l'input
         *
         * @param   {Event}  e  [e description]
         *
         * @return  {boolean}     [return description]
         */
        input.oninput = ((e) => { 
            let target = e.target.value;
            if (target.length > 2) {
                this.initHashTable(this.listElement, target);
                this.secondRender()
            } else {
                this.tableHash = [];
                this.secondRender();
            }
        })
    }

    /**
     * Creer une table de hash en de l'ensemble des mots dans Array 
     * et filtre l'array si value est = à une valeur dans l'array
     *
     * @param   {Array}  array  [array description]
     * @param   {string}  value  [value description]
     *
     * @return  {void}         [return description]
     */
    initHashTable (array, value) {
        let word;
        for (let i = 0, size = this.listElement.length; i < size; i++){
            let bigTitle = array[i];
            let newTitle = bigTitle.split(" ");
            newTitle.forEach(el => {
                for(let ii = 0, size = el.length; ii<size; ii++){
                    word = el.slice(0, ii);
                    if(word === value){
                        console.log(array[i]);
                        if(this.tableHash.indexOf(array[i]) === -1) {
                            this.tableHash.push(array[i])
                        };
                    }
                }
            });
        }
    }

    /**
     * [addArrow description]
     *
     * @param   {HTMLElement}  parent     [parent description]
     *
     */
    addArrow(parent) {
        const arrow__container = document.createElement('div');
        arrow__container.setAttribute('class', 'filtreButton__Arrow')
        arrow__container.innerHTML += `<i class="fas fa-chevron-${this.clickValue == false ? 'down' : 'up'}"></i>`;
        arrow__container.style.cursor = 'pointer';
        parent.appendChild(arrow__container)
        arrow__container.onclick = (e) => {
            e.stopPropagation();
            this.clickValue = !this.clickValue;
            if (this.clickValue) {
                this.render();
                this.addTag(this.DOM, this.callback);
                this.DOM.classList.add('click');
            } else {
                this.DOM.classList.remove('click');
                this.render();
            };
        }
    }


    /**
     * [addTag description]
     *
     * @param   {HTMLElement}  parent    [parent description]
     * @param   {Function}  callback  [callback description]
     * 
     * @returns {void}
     *
     */
    addTag(parent, callback) {
        const tagContainer = document.createElement("div");
        tagContainer.setAttribute('class', 'tagContainer');
        tagContainer.style.cursor = 'pointer';
        let list = this.tableHash.length > 0 ? this.tableHash : this.listElement;
        list.forEach(element => {
            const tagContainer__tag = document.createElement('span');
            tagContainer__tag.setAttribute('class', 'tagContainer__tag '+ element);
            tagContainer__tag.innerHTML = element;
            tagContainer.appendChild(tagContainer__tag);
            tagContainer__tag.onclick = () => {
                this.clickValue = !this.clickValue;
                this.DOM.classList.remove('click');
                callback(this.title, element);
                this.render();
            }
        });

        parent.appendChild(tagContainer);
    }

    /**
     * Gestion des données affichés dans les bouton en fonction de leurs titres
     *
     * @return  {Object}  [return description]
     */
    get listElement() {
        if (this.title == "Ingredients") return updateIngredientList();
        if (this.title == "Appareil") return updateApplianceList();
        return updateUstensilsList();
    }
}

import { updateUstensilsList, updateApplianceList, updateIngredientList } from "../Data/dataManagers.js";

export class FiltreButton {

    constructor(domTarget, callback, title, phrasing, callBackTaget) {
        this.DOM = document.createElement('button');
        domTarget.appendChild(this.DOM);
        this.DOM.setAttribute('class', 'filtreButton ' + title)
        this.callback = callback;
        this.title = title;
        this.phrasing = phrasing;
        this.click = false;
        this.render();
    }

    render() {
        this.addInput();
    }

    secondRender(){
        
    }

    addInput() {
        
    }

    addArrow() {

    } 

    addTag() {

    }

    get listElement() {
        if (this.title == "Ingredients") return updateIngredientList();
        if (this.title == "Appareil") return updateApplianceList();
        return updateUstensilsList();
    }

}
